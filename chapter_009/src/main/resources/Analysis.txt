Анализ с помощью jmap.
    При запуске утилиты можно увидеть, что кроме созданных нами объектов, в память загружается множество объектов
    внутренних классов виртуальной машины.
     - При добавлении пользователем новой заявки, утилита отображает новый объект заявки и так же новые, созданные
    автоматически, объекты виртуальной машины.
     - При отображении всех заявок, даже при том, что логикой программы не предусмотрено создание объекта, новые объекты
    виртуальной машины создаются.
     - При редактировании заявки, программа создаёт новый объект заявки, утилита теперь отображает что в памяти храниться
     два объекта, старая заявка и новая.
     - При удалении заявки, на самом деле объект остаётся в памяти. Объект удалиться только в случае запуска сборщика
     мусора.
	 - При поиске заявок по id или названию в памяти создаются объекты виртуальной машины.
	 - При создании большого количества заявок (10млн) запускается GC для очистки памяти от лишних объектов. Это видно
	 по отсутствию некоторых объектов внутренних классов, которые отображала утилита ранее.
	 - При новой попытке создать множество заявок, программа на время останавливается, так как запускается GC,
	который пытается очистить память, и при неудаче, программа финиширует с ошибкой нехватки памяти.
	
Анализ с помошью jstat
	 - При первом запуске программы MemTracker и утилиты jstat, можно увидеть что объекты загружаются в область памяти Eden.
	 - По мере заполнения области Eden Space, для возможности добавления новых объектов, запустится GC для очистки от
	 неиспользуемых объектов  , и "живые" объекты перенесутся в область Survivor Space(обычно Survivor1).
	 - Когда заполнится область Survivor1, вновь вызовется GC, а живые объекты перенесутся в Survivor0 или же в Old Space.
	 - При переносе объектов в Old Space, GC производит очистку (Mojor GC).
	 - Так же по мере увеличения количества объектов в памяти, ёмкость областей Eden, Survivor0, Survivor1 и Old Space будет
	 увеличиваться.
	 - Когда лимит памяти будет исчерпываться, в зависимости от используемого GC, может запускаться большая очистка (Full GC),
	 она затронет как молодое поколение объектоа, так и старое.
	 - В конце, если места для новых объектов будет не хватать, из за заполненности всех областей, программа завершится с
	 ошибкой недостатка памяти.
	 
Анализ с помощью jconsole
	 - Этот инструмент для анализа отображает четыре главных значения. 
		1. Используемая память heap'a.
		2. Количество потоков.
		3. Количество загруженных классов.
		4. Использование процессора.
	 - По первому значению видно, что эта утилита сама сильно нагружает процесс, это видно по тому, что память heap'a ежесекундно
	   заполняется, а по достижению определённого значения, очищается и это повторяется снова. Эта программа больше подходит для анализа
	   больших приложений, где работа этой утилиты не будет мешать получать актуальную информацию.
	 - А в целом утилита схожа с jmap, которую мы использовали ранее, и может помогать следить как приложение работает с памятью.
	 - К тому же в отличии от jmap, jconsole более удобен благодаря наличию графического интерфейса и работе в режиме реального времени.
	 
	 